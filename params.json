{
  "name": "Beeschema",
  "tagline": "Binary Schema Library for C#",
  "body": "![BeeSchema Logo](beeschema.png)\r\n\r\n# BeeSchema\r\n## Binary Schema Library for C&#35;\r\n\r\nBeeSchema allows you to define the structure of a binary file using a simple schema (&#42;.bee) file, then read the file in a much more human way.  No more BinaryReader or manually reading data from Streams.\r\n\r\n*NOTE: BeeSchema is still in development, so things may change and other things might not be too optimised.  Also, BeeSchema was designed as a replacement for the limited structure definition support in [Ostara](https://github.com/Epidal/Ostara).  As such, some features that you require may not be supported.*\r\n\r\n\r\n## Schema Files\r\nThe structure of a binary file to be parsed by BeeSchema is defined in a simple text file (usually with the extension &#42;.bee) that uses a custom language designed specifically for this purpose.  These schemas can then be loaded by BeeSchema, and later used to parse binary files and turn them into more human-readable data.\r\nThe basic structure of any schema file consists of optional custom data types and a **schema** block that represents the entry point of the schema file.  This block is where BeeSchema will begin its parsing of binary files.  For example, a schema file for a simple binary file that consists of a 32-bit integer followed by an 8-bit integer might look like this:\r\n```elm\r\nschema {\r\n  first_var : Int;\r\n  next_var  : Byte;\r\n}\r\n```\r\n\r\n\r\n### Primitive Data Types\r\nBeeSchema supports a number of primitive data types.  The following table lists these types, along with a short description and their size in bytes.\r\n\r\n*NOTE: Primitive type names are case-insensitive, so `an_int : int` is exactly the same as `an_int : Int`*\r\n\r\nType | Size (bytes) | Description\r\n--- | --- | ---\r\nbool | 1 | A boolean value (true or false)\r\nbyte | 1 | An unsigned 8-bit integer\r\nsbyte | 1 | A signed 8-bit integer\r\nushort | 2 | An unsigned 16-bit integer\r\nshort | 2 | A signed 16-bit integer\r\nuint | 4 | An unsigned 32-bit integer\r\nint | 4 | A signed 32-bit integer\r\nulong | 8 | An unsigned 64-bit integer\r\nlong | 8 | A signed 64-bit integer\r\nfloat | 4 | A 32-bit floating point integer\r\ndouble | 8 | A 64-bit floating point integer\r\nipaddress | 4 | A 32-bit representation of an IP address, where each byte represents a portion of the address (eg. 0x04030201 = 1.2.3.4)\r\nepoch | 4 | A 32-bit value representing a date and time in Unix format (seconds since 01/01/1970)\r\n\r\nArrays are also supported.  They can be declared like so:\r\n```elm\r\na_byte_array  : Byte[7];\r\n```\r\nYou can use a previously-declared variable for the array length:\r\n```elm\r\nsome_int      : Int;\r\nanother_array : Float[some_int];\r\n```\r\nand even perform arithmetic operations in the length specifier:\r\n```elm\r\nsome_other_int        : Int;\r\noh_look_another_array : Char[some_other_int / 4];\r\n```\r\n*NOTE: Referencing variables inside a custom type is not currently supported, but is planned for the future.  Absolute and relative pointers may also be added.*\r\n\r\n\r\n### Custom Data Types\r\nBeeSchema also supports custom data types in the form of structures, enumerations and bitfields.\r\n\r\n#### Structures\r\nStructures can be used to define the structure of a block of data.  They are useful for when your data file contains several blocks of data that share the same format.  Structures are defined with the **struct** keyword, and can contain any type and number of other variables, including other previously defined structures, enumerations or bitfields:\r\n```elm\r\nstruct MyStruct {\r\n  my_int  : Int;\r\n}\r\n```\r\nOnce defined, structures can be used like any other type:\r\n```elm\r\nmy_struct : MyStruct;\r\n```\r\nWhen parsing structures, BeeSchema will return a collection of results, with each one representing a separate variable inside the struct (the same applies to bitfields and arrays).\r\n\r\n#### Enumerations\r\nEnumerations can be used for variables that have a fixed number of values that you might want to associate names with.  By default, values in an enumeration start at zero and increment by 1, but they can also be manually assigned.  Enumerations are defined with the **enum** keyword and must always declare a base type so that BeeSchema knows the size of the data to read:\r\n```elm\r\nenum MyEnum : Int {\r\n  AValueThatIsZero,\r\n  ThisValueIsOne,\r\n  ThisIsTwo,\r\n  ButThisIsSeven = 7\r\n  AndNowThisIsEight\r\n}\r\n```\r\n\r\n#### Bitfields\r\nBitfields are used to represent data that packs several values together.  They are defined with the **bitfield** keyword and, like enumerations, must declare a base type.  Additionally, each variable inside a bitfield must specify its size in bits:\r\n```elm\r\nbitfield MyBitfield : Byte {\r\n  first_bit             : 1;\r\n  second_to_fourth_bits : 3;\r\n  remaining_bits        : 4;\r\n}\r\n```\r\n\r\n\r\n### Conditionals and Loops\r\nBeeSchema has basic support for conditionals and loops, including **if**, **unless**, **while**, and **until**.  Conditions for these can consist of references to previously-defined variables, macros, and comparison operators (!, ==, !=, <, >, <=, and >=).  Conditions can be chained together using OR (||) or AND (&&):\r\n```elm\r\nif (some_value > 5 && another_value <= 42) {\r\n  an_int  : Int;\r\n  a_short : Short;\r\n}\r\n```\r\nThe following table lists the currently supported conditionals and loops and a brief description of their purpose.\r\n\r\nKeyword | Description\r\n--- | ---\r\nif | If the condition is met, any variables in the associated block will be evaluated\r\nunless | Like **if**, but only evaluates the associated block if the condition is **not** met\r\nwhile | Evaluates the variables in the associated block while the condition is true\r\nuntil | Evaluates the variables in the associated block while the condition is false\r\n\r\n\r\n### Macros\r\nBeeSchema supports a few macros that provide information about the current binary file being parsed.  They can be used as conditions and in array length specifiers.  Macros are prepended with the **@** character and evaluated by BeeSchema while binary data is being parsed.  The following table lists the currently supported macros and what they represent.\r\n\r\nMacro | Description\r\n--- | ---\r\n@eof | Evaluates to **true** if the end of the binary data has been reached\r\n@size | Evaluates to the size of the binary data\r\n@pos | Evaluates to the current position of the parser in the binary data\r\n\r\n\r\n### Comments\r\nSchema files support both single-line and block (multi-line) comments.  When BeeSchema discovers a comment, it will attach it to the most recently-declared variable.  This is useful for including annotations that you would like to display in your program along with the data.\r\n\r\n#### Single-Line Comments\r\nSingle-line comments are declared by the **&#35;** character, followed by the comment itself:\r\n```elm\r\na_string  : String;   # This is a comment!\r\n```\r\n\r\n#### Block (Multi-Line) Comments\r\nMulti-Line comments (otherwise known as \"block comments\") are declared by wrapping the comment text in double-hashes (ie. two **&#35;** characters):\r\n```\r\n## This is\r\na multiline\r\ncomment.\r\n##\r\n```\r\n\r\n\r\n### Including Schema Files\r\nBeeSchema allows you to include other schema files inside your schema file.  This will import all of the defined custom data types, but will ignore the **schema** block inside that file:\r\n```elm\r\ninclude some_schema_file.bee;\r\n```\r\nThis can be useful when several data formats share common types as it prevents you from having to repeat code and helps reduce the size of schema files.\r\n\r\n\r\n### Example Schema File\r\nHere's an example schema file that demonstrates all of the current features of BeeSchema:\r\n```elm\r\n# We can include external files so that we can use types defined in them\r\ninclude somefile.bee;\r\n\r\n# This is a single-line comment\r\n\r\n##\r\n\tThis is a\r\n\tmulti-line\r\n\tcomment.\r\n##\r\n\r\nstruct SomeStruct {\r\n\ta_bool\t\t: bool;\r\n\ta_byte\t\t: byte;\r\n\tan_sbyte\t: sbyte;\r\n\ta_ushort\t: ushort;\r\n\ta_short\t\t: short;\r\n\tan_int\t\t: int;\r\n\ta_uint\t\t: uint;\r\n\ta_long\t\t: long;\r\n\ta_ulong\t\t: ulong\r\n\ta_float\t\t: float;\r\n\ta_double\t: double;\r\n\ta_string\t: string;\r\n\tan_ip\t\t: ipaddress;\r\n\ta_timestamp\t: epoch\r\n}\r\n\r\n# Enum and bitfield definitions require a base type\r\nenum SomeEnum : byte {\r\n\tSomeValue1,\r\n\tSomeValue2,\r\n\tAnotherValue = 10,\r\n\tYetAnotherValue\r\n}\r\n\r\nbitfield SomeBitfield : byte {\r\n\tfirst_bit\t: 1;\r\n\tnext_3_bits\t: 3;\r\n\tlast_4_bits\t: 4;\r\n}\r\n\r\nschema {\r\n\ta_struct    : SomeStruct;   # Variables can be annotated by using a comment\r\n\tan_enum     : SomeEnum;\r\n\ta_bitfield  : SomeBitfield;\r\n\tlength      : Int;\r\n\tan_array    : Char[length];\r\n\tan_array2   : Int[4 * 2];\r\n\tan_array3   : Byte[@size - @pos - 32];\r\n\tint_1,\r\n\tint_2,\r\n\tint_3       : Int;  # Multiple variables of the same type can be declared by separating them with a comma\r\n\r\n\tuntil(@eof) {\r\n\t\tsome_var    : Float;\r\n\t\tanother_var : Epoch;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n## Using BeeSchema\r\nTo use BeeSchema, create an instance of the **Schema** class using the static **FromFile()** or **FromText()** methods.  You can then parse a binary file by passing the filename, a byte array, or a Stream object to the instance's **Parse()** method.  Please see [the Example project](Example/Program.cs) for a simple example on how to use BeeSchema and the resulting parsed data.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}